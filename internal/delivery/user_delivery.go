/*
 * Backend for Online Shop
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package delivery

import (
	"OnlineShopBackend/internal/models"
	"fmt"
	"net/http"
	"unicode"

	//"github.com/dghubble/gologin/v2"
	//"github.com/dghubble/gologin/v2/google"
	"github.com/dghubble/sessions"
	"github.com/gin-gonic/gin"

	"golang.org/x/oauth2"
	og2 "golang.org/x/oauth2/google"
)

const (
	sessionName     = "example-google-app"
	sessionSecret   = "example cookie signing secret"
	sessionUserKey  = "key"
	sessionUserID = "user"
)

var sessionStore = sessions.NewCookieStore([]byte(sessionSecret), nil)


// CreateUser create a new user
//
//	@Summary		Create a new user
//	@Description	Method provides to get quantity of items
//	@Tags			user
//	@Accept			json
//	@Produce		json
//	@Success		200	{object}	id	"user id"
//	@Failure		404	"Bad Request"
//	@Failure		404	{object}	ErrorResponse	"404 Not Found"
//	@Failure		500	{object}	ErrorResponse
//	@Router			/user/create [post]
func (delivery *Delivery) CreateUser(c *gin.Context) {
	delivery.logger.Debug("Enter in delivery CreateUser()")
	ctx := c.Request.Context()
	var deliveryUser *models.User
	if err := c.ShouldBindJSON(&deliveryUser); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check if this a new user
	if _, err := delivery.userUsecase.GetUserByEmail(ctx, deliveryUser.Email); err != nil {
		return
	}


	if err := validationCheck(*deliveryUser); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	id, err := delivery.userUsecase.CreateUser(ctx, deliveryUser)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
	}
	c.JSON(http.StatusOK, gin.H{"success": id.String()})
}

// LoginUser -
func (delivery *Delivery) LoginUser(c *gin.Context) {
	delivery.logger.Debug("Enter in delivery LoginUser()")
	var deliveryUser models.User
	if err := c.ShouldBindJSON(&deliveryUser); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	user, err := delivery.userUsecase.GetUserByEmail(c.Request.Context(), deliveryUser.Email); if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	session := sessions.NewSession(sessionStore, sessionName)
	session.Values[sessionUserID] = user.ID
	if err := session.Save(c.Writer); err != nil {
		delivery.logger.Error("saving session error")
		return
	}
	c.JSON(http.StatusOK, gin.H{"token": session.Values[sessionUserID]})
}

// LoginUserGoogle -
func (delivery *Delivery) LoginUserGoogle(c *gin.Context) {
	delivery.logger.Debug("Enter in delivery LogoutUser()")
	oauth2Config := &oauth2.Config{
		ClientID: "614400740650-ioroeqq2rvn45k5tv5rc8noa7058m1l9.apps.googleusercontent.com",
		ClientSecret: "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",
		RedirectURL:  "http://localhost:8000/user/callbackGoogle",
		Endpoint:     og2.Endpoint,
		Scopes:       []string{"profile", "email"},
	}
	url := oauth2Config.AuthCodeURL("random")
	http.Redirect(c.Writer, c.Request, url,  http.StatusTemporaryRedirect)
	//stateConfig := gologin.DefaultCookieConfig
	//google.StateHandler(stateConfig, google.CallbackHandler(oauth2Config, issueSession(), nil)).ServeHTTP(c.Writer, c.Request)
}

// LoginUserYandex -
func (delivery *Delivery) LoginUserYandex(c *gin.Context) {
	delivery.logger.Debug("Enter in delivery LogoutUser()")
	c.JSON(http.StatusOK, gin.H{})
}

// CallbackGoogle -
func (delivery *Delivery) CallbackGoogle(c *gin.Context) {
	delivery.logger.Debug("Enter in delivery LogoutUser()")

	c.Redirect(http.StatusTemporaryRedirect, "http://localhost:3000")
}

// CallbackYandex -
func (delivery *Delivery) CallbackYandex(c *gin.Context) {
	delivery.logger.Debug("Enter in delivery LogoutUser()")
	c.JSON(http.StatusOK, gin.H{})
}

// LogoutUser -
func (delivery *Delivery) LogoutUser(c *gin.Context) {
	delivery.logger.Debug("Enter in delivery LogoutUser()")
	//session, _ := sessionStore.Get(c.Request, sessionName)
	//session.Values[sessionUserID] = nil
	//session.Save(c.Writer)

	sessionStore.Destroy(c.Writer, sessionName)
	c.JSON(http.StatusOK, gin.H{"you have been successfully logged out": nil})
	c.Redirect(http.StatusTemporaryRedirect, "/")
}

func validationCheck(user models.User) error {
	if user.Email == "" && user.Firstname == "" && user.Lastname == "" {
		return fmt.Errorf("empty filed")
	}
	if len(user.Password) < 5 {
		return fmt.Errorf("password is too short")
	}
	for _, char := range user.Password {
		if !unicode.IsDigit(char) && !unicode.Is(unicode.Latin, char) {
			return fmt.Errorf("password should contain lathin letter or numbers only")
		}
	}
	return nil
}

func randSession(n int)  {

}



//func issueSession() http.Handler {
//	fn := func(w http.ResponseWriter, req *http.Request) {
//		ctx := req.Context()
//		googleUser, err := google.UserFromContext(ctx)
//		if err != nil {
//			http.Error(w, err.Error(), http.StatusInternalServerError)
//			return
//		}
//		// 2. Implement a success handler to issue some form of session
//		session := sessionStore.New(sessionName)
//		session.Values[sessionUserKey] = googleUser.Id
//		session.Values[sessionUsername] = googleUser.Name
//		session.Save(w)
//		http.Redirect(w, req, "/", http.StatusFound)
//	}
//	return http.HandlerFunc(fn)
//}